#!/bin/bash
# ============================================================
# Biblioteca de funciones para manejo din√°mico de nodos basado en NODES_CONFIG
# Autor: @SktCod.ByChisto
# Versi√≥n: 2.0

set -euo pipefail
trap 'echo "‚ùå Error en l√≠nea $LINENO durante instalaci√≥n de MetalLB. Revisa el log." && exit 1' ERR

# Cargar variables y funciones
[ -f .env ] && source .env || { echo "‚ùå Falta archivo .env"; exit 1; }
[ -f scripts/node-helpers.sh ] && source scripts/node-helpers.sh || { echo "‚ùå Falta archivo scripts/node-helpers.sh"; exit 1; }

LOG="logs/04-install-metallb-$(date +%F-%H%M).log"
mkdir -p logs && exec > >(tee -a "$LOG") 2>&1

echo "üåê Iniciando instalaci√≥n de MetalLB..."

# 1. VALIDACIONES INICIALES
# =========================
validate_nodes_config

# Validar configuraci√≥n de subdominios
validate_subdomain_config

export PATH=$PATH:/var/lib/rancher/rke2/bin
export KUBECONFIG=${KUBECONFIG:-/etc/rancher/rke2/rke2.yaml}

# Verificar que kubeconfig use el endpoint correcto
if ! grep -q "$K8S_API_DOMAIN" "$KUBECONFIG" 2>/dev/null; then
  echo "‚ö†Ô∏è  Warning: kubeconfig no apunta a $K8S_API_DOMAIN"
  echo "üí° Ejecuta primero: scripts/02-install-cluster.sh"
fi

# Verificar comandos requeridos
for cmd in kubectl; do
  command -v $cmd &>/dev/null || { 
    echo "‚ùå Falta comando: $cmd"
    echo "üí° Aseg√∫rate de que RKE2 est√© instalado correctamente"
    exit 1
  }
done

# Verificar que el cl√∫ster est√© funcionando
if ! kubectl get nodes &>/dev/null; then
  echo "‚ùå El cl√∫ster Kubernetes no est√° accesible"
  echo "üí° Ejecuta primero: scripts/02-install-cluster.sh"
  exit 1
fi

# 2. VALIDAR CONFIGURACI√ìN DE METALLB
# ===================================
echo "üîç Validando configuraci√≥n de MetalLB..."

if [ -z "${METALLB_IP_RANGE:-}" ]; then
  echo "‚ùå METALLB_IP_RANGE no est√° definido en .env"
  echo "üí° Ejemplo: METALLB_IP_RANGE=192.168.1.100-192.168.1.110"
  exit 1
fi

if [ -z "${LB_IP:-}" ]; then
  echo "‚ùå LB_IP no est√° definido en .env"
  echo "üí° Ejemplo: LB_IP=192.168.1.100"
  exit 1
fi

echo "üìä Configuraci√≥n de MetalLB:"
echo "   ‚Ä¢ Rango de IPs: $METALLB_IP_RANGE"
echo "   ‚Ä¢ LoadBalancer IP: $LB_IP"

# Validar formato del rango de IPs
if [[ ! "$METALLB_IP_RANGE" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
  echo "‚ùå Formato de METALLB_IP_RANGE inv√°lido"
  echo "üí° Formato correcto: IP_INICIO-IP_FIN (ej: 192.168.1.100-192.168.1.110)"
  exit 1
fi

# Extraer IPs de inicio y fin
START_IP=$(echo "$METALLB_IP_RANGE" | cut -d'-' -f1)
END_IP=$(echo "$METALLB_IP_RANGE" | cut -d'-' -f2)

echo "   ‚Ä¢ IP inicial: $START_IP"
echo "   ‚Ä¢ IP final: $END_IP"

# 3. VERIFICAR CONECTIVIDAD DE RED
# ================================
echo "üîó Verificando conectividad de red..."

# Verificar que LB_IP est√© en el rango o sea accesible
echo -n "‚û°Ô∏è  Verificando acceso a LB_IP ($LB_IP): "
if ping -c 1 -W 3 "$LB_IP" &>/dev/null; then
  echo "‚úÖ LB_IP es accesible"
else
  echo "‚ö†Ô∏è  LB_IP no responde a ping (puede ser normal si est√° configurado)"
fi

# Verificar que las IPs del rango est√©n libres
echo "üîç Verificando disponibilidad de IPs en el rango..."
IP_CONFLICTS=0

# Funci√≥n para verificar IP
check_ip_availability() {
  local ip=$1
  if ping -c 1 -W 1 "$ip" &>/dev/null; then
    echo "‚ö†Ô∏è  IP $ip est√° en uso"
    ((IP_CONFLICTS++))
  else
    echo "‚úÖ IP $ip disponible"
  fi
}

# Verificar algunas IPs del rango (para no saturar la salida)
check_ip_availability "$START_IP"
check_ip_availability "$END_IP"

if [ $IP_CONFLICTS -gt 0 ]; then
  echo "‚ö†Ô∏è  Se detectaron $IP_CONFLICTS IPs en uso en el rango"
  echo "üîÑ ¬øContinuar de todas formas? (y/N)"
  read -r -n 1 response
  echo
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    echo "‚ùå Instalaci√≥n cancelada por el usuario"
    exit 1
  fi
fi

# 4. VERIFICAR INSTALACI√ìN PREVIA
# ===============================
echo "üîç Verificando instalaci√≥n previa de MetalLB..."

if kubectl get namespace metallb-system &>/dev/null; then
  echo "‚ö†Ô∏è  MetalLB ya est√° instalado"
  echo "üìã Estado actual:"
  kubectl -n metallb-system get pods
  echo ""
  echo "üîÑ ¬øDeseas reinstalar MetalLB? (y/N)"
  read -r -n 1 response
  echo
  if [[ "$response" =~ ^[Yy]$ ]]; then
    echo "üóëÔ∏è  Desinstalando MetalLB previo..."
    kubectl delete namespace metallb-system --timeout=120s || true
    sleep 30
  else
    echo "‚úÖ Manteniendo instalaci√≥n existente de MetalLB"
    echo "üëâ Contin√∫a con: scripts/05-install-rancher.sh"
    exit 0
  fi
fi

# 5. INSTALAR METALLB
# ===================
echo "üì¶ Instalando MetalLB..."

# Determinar versi√≥n de MetalLB
METALLB_VERSION="v0.13.12"
METALLB_MANIFEST_URL="https://raw.githubusercontent.com/metallb/metallb/$METALLB_VERSION/config/manifests/metallb-native.yaml"

echo "‚¨áÔ∏è  Descargando manifesto de MetalLB $METALLB_VERSION..."
curl -sL "$METALLB_MANIFEST_URL" -o metallb-native.yaml

echo "üîß Aplicando manifesto de MetalLB..."
kubectl apply -f metallb-native.yaml

# 6. ESPERAR A QUE METALLB EST√â LISTO
# ===================================
echo "‚è≥ Esperando a que MetalLB est√© listo..."

# Esperar a que el namespace est√© disponible
for i in {1..10}; do
  if kubectl get namespace metallb-system &>/dev/null; then
    echo "‚úÖ Namespace metallb-system creado"
    break
  fi
  if [ $i -eq 10 ]; then
    echo "‚ùå Timeout esperando namespace metallb-system"
    exit 1
  fi
  echo "‚è≥ Esperando namespace... (intento $i/10)"
  sleep 5
done

# Esperar a que el controlador est√© listo
echo "‚è≥ Esperando controlador MetalLB..."
for i in {1..20}; do
  if kubectl -n metallb-system rollout status deployment/controller --timeout=30s &>/dev/null; then
    echo "‚úÖ Controlador MetalLB est√° listo"
    break
  fi
  if [ $i -eq 20 ]; then
    echo "‚ùå Timeout esperando controlador MetalLB"
    echo "üìã Estado actual:"
    kubectl -n metallb-system get pods
    exit 1
  fi
  echo "‚è≥ Esperando controlador... (intento $i/20)"
  sleep 15
done

# Esperar a que el speaker est√© listo
echo "‚è≥ Esperando speaker MetalLB..."
for i in {1..20}; do
  if kubectl -n metallb-system rollout status daemonset/speaker --timeout=30s &>/dev/null; then
    echo "‚úÖ Speaker MetalLB est√° listo"
    break
  fi
  if [ $i -eq 20 ]; then
    echo "‚ùå Timeout esperando speaker MetalLB"
    echo "üìã Estado actual:"
    kubectl -n metallb-system get pods
    exit 1
  fi
  echo "‚è≥ Esperando speaker... (intento $i/20)"
  sleep 15
done

# 7. CONFIGURAR IPADDRESSPOOL
# ===========================
echo "üèä Configurando IPAddressPool..."

cat > metallb-ippool.yaml <<EOF
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: default-pool
  namespace: metallb-system
  labels:
    app: metallb
spec:
  addresses:
  - $METALLB_IP_RANGE
  autoAssign: true
  avoidBuggyIPs: true
EOF

kubectl apply -f metallb-ippool.yaml

# 8. CONFIGURAR L2ADVERTISEMENT
# =============================
echo "üì¢ Configurando L2Advertisement..."

cat > metallb-l2adv.yaml <<EOF
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2adv
  namespace: metallb-system
  labels:
    app: metallb
spec:
  ipAddressPools:
  - default-pool
  interfaces:
  - eth0
  - ens18
  - ens192
  nodeSelectors:
  - matchLabels:
      kubernetes.io/os: linux
EOF

kubectl apply -f metallb-l2adv.yaml

# 9. VERIFICAR CONFIGURACI√ìN
# ==========================
echo "üîç Verificando configuraci√≥n de MetalLB..."

# Verificar IPAddressPool
echo -n "‚û°Ô∏è  IPAddressPool: "
if kubectl -n metallb-system get ipaddresspool default-pool &>/dev/null; then
  echo "‚úÖ Configurado correctamente"
else
  echo "‚ùå Error en configuraci√≥n"
  exit 1
fi

# Verificar L2Advertisement
echo -n "‚û°Ô∏è  L2Advertisement: "
if kubectl -n metallb-system get l2advertisement l2adv &>/dev/null; then
  echo "‚úÖ Configurado correctamente"
else
  echo "‚ùå Error en configuraci√≥n"
  exit 1
fi

# 10. CREAR SERVICIO DE PRUEBA
# ============================
echo "üß™ Creando servicio de prueba LoadBalancer..."

cat > metallb-test-service.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: metallb-test
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: metallb-test
  template:
    metadata:
      labels:
        app: metallb-test
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
---
apiVersion: v1
kind: Service
metadata:
  name: metallb-test-service
  namespace: default
spec:
  type: LoadBalancer
  selector:
    app: metallb-test
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
EOF

kubectl apply -f metallb-test-service.yaml

# Esperar a que el servicio obtenga una IP externa
echo "‚è≥ Esperando asignaci√≥n de IP externa..."
for i in {1..24}; do
  EXTERNAL_IP=$(kubectl get service metallb-test-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
  
  if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
    echo "‚úÖ IP externa asignada: $EXTERNAL_IP"
    
    # Verificar que la IP est√© en el rango configurado
    if [[ "$EXTERNAL_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      echo "‚úÖ IP v√°lida asignada del pool configurado"
      
      # Probar conectividad
      echo -n "üîó Probando conectividad HTTP: "
      if curl -s --max-time 10 "http://$EXTERNAL_IP" | grep -q "nginx" &>/dev/null; then
        echo "‚úÖ Servicio LoadBalancer funcional"
      else
        echo "‚ö†Ô∏è  Servicio no responde (puede ser normal, verificar red)"
      fi
    else
      echo "‚ö†Ô∏è  IP asignada no est√° en formato esperado"
    fi
    break
  fi
  
  if [ $i -eq 24 ]; then
    echo "‚ùå Timeout esperando IP externa (6 minutos)"
    echo "üìã Estado del servicio:"
    kubectl describe service metallb-test-service
    echo ""
    echo "üìã Eventos recientes:"
    kubectl get events --sort-by=.metadata.creationTimestamp | tail -10
  else
    echo "‚è≥ Esperando IP externa... (intento $i/24)"
    sleep 15
  fi
done

# 11. LIMPIAR SERVICIO DE PRUEBA
# ==============================
echo "üßπ Limpiando servicio de prueba..."
kubectl delete -f metallb-test-service.yaml || true
rm -f metallb-test-service.yaml

# 12. VERIFICACI√ìN FINAL
# ======================
echo ""
echo "üìä Estado final de MetalLB:"
kubectl -n metallb-system get pods -o wide

echo ""
echo "üèä Configuraci√≥n de pools de IP:"
kubectl -n metallb-system get ipaddresspool

echo ""
echo "üì¢ Configuraci√≥n de L2 Advertisement:"
kubectl -n metallb-system get l2advertisement

# 13. INFORMACI√ìN ADICIONAL
# =========================
echo ""
echo "üîß Informaci√≥n de configuraci√≥n de red:"
echo "   ‚Ä¢ Interfaces de red detectadas:"
kubectl -n metallb-system get pods -l app=metallb,component=speaker -o wide | grep -v NAME | while read -r pod rest; do
  echo "      $pod"
done

echo ""
echo "üéâ Instalaci√≥n de MetalLB completada exitosamente"
echo "üìä Resumen:"
echo "   ‚Ä¢ Versi√≥n: $METALLB_VERSION"
echo "   ‚Ä¢ Namespace: metallb-system"
echo "   ‚Ä¢ Pool de IPs: $METALLB_IP_RANGE"
echo "   ‚Ä¢ Modo: L2 Advertisement"
echo "   ‚Ä¢ Estado: Funcional"

if [ -n "${EXTERNAL_IP:-}" ]; then
  echo "   ‚Ä¢ IP de prueba asignada: $EXTERNAL_IP"
fi

echo ""
echo "üìÅ Archivos generados:"
echo "   ‚Ä¢ metallb-native.yaml (manifesto base)"
echo "   ‚Ä¢ metallb-ippool.yaml (configuraci√≥n de pool)"
echo "   ‚Ä¢ metallb-l2adv.yaml (configuraci√≥n L2)"
echo ""
echo "üí° Uso:"
echo "   Los servicios tipo LoadBalancer ahora obtendr√°n IPs del rango $METALLB_IP_RANGE"
echo ""
echo "üëâ Contin√∫a con: scripts/05-install-rancher.sh"
