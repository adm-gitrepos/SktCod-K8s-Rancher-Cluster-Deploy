#!/bin/bash
set -euo pipefail
trap 'echo "‚ùå Error en l√≠nea $LINENO durante verificaci√≥n. Revisa el log." && exit 1' ERR

# Cargar variables y funciones
[ -f .env ] && source .env || { echo "‚ùå Falta archivo .env"; exit 1; }
[ -f scripts/node-helpers.sh ] && source scripts/node-helpers.sh || { echo "‚ùå Falta archivo scripts/node-helpers.sh"; exit 1; }

LOG="logs/06-verify-installation-$(date +%F-%H%M).log"
mkdir -p logs && exec > >(tee -a "$LOG") 2>&1

echo "üîç Iniciando verificaci√≥n completa del cl√∫ster..."

# 1. CONFIGURACI√ìN INICIAL
# ========================
validate_nodes_config

# Validar configuraci√≥n de subdominios
validate_subdomain_config

export PATH=$PATH:/var/lib/rancher/rke2/bin
export KUBECONFIG=${KUBECONFIG:-/etc/rancher/rke2/rke2.yaml}

# Verificar que kubeconfig use el endpoint correcto
if ! grep -q "$K8S_API_DOMAIN" "$KUBECONFIG" 2>/dev/null; then
  echo "‚ö†Ô∏è  Warning: kubeconfig no apunta a $K8S_API_DOMAIN"
  echo "üí° Ejecuta primero: scripts/02-install-cluster.sh"
fi

# Verificar kubectl
if ! command -v kubectl &>/dev/null; then
  echo "‚ùå kubectl no est√° disponible"
  exit 1
fi

# Verificar acceso al cl√∫ster
if ! kubectl get nodes &>/dev/null; then
  echo "‚ùå No se puede acceder al cl√∫ster Kubernetes"
  exit 1
fi

echo "‚úÖ Acceso al cl√∫ster confirmado"

# 2. VERIFICACI√ìN DE NODOS
# ========================
echo ""
echo "üñ•Ô∏è  VERIFICACI√ìN DE NODOS"
echo "=========================="

# Mostrar todos los nodos
echo "üìä Estado de todos los nodos:"
kubectl get nodes -o wide

echo ""
echo "üè∑Ô∏è  Etiquetas y roles de nodos:"
kubectl get nodes --show-labels | grep -E "(NAME|master|worker|storage)"

# Contar nodos por tipo
EXPECTED_MASTERS=$(echo "$NODES_CONFIG" | jq -r '[to_entries[] | select(.value.type == "master")] | length')
EXPECTED_WORKERS=$(echo "$NODES_CONFIG" | jq -r '[to_entries[] | select(.value.type == "worker")] | length')
EXPECTED_STORAGE=$(echo "$NODES_CONFIG" | jq -r '[to_entries[] | select(.value.type == "storage")] | length')
EXPECTED_TOTAL=$((EXPECTED_MASTERS + EXPECTED_WORKERS + EXPECTED_STORAGE))

ACTUAL_NODES=$(kubectl get nodes --no-headers | wc -l)
READY_NODES=$(kubectl get nodes --no-headers | grep -c " Ready " || echo "0")

echo ""
echo "üìà Resumen de nodos:"
echo "   ‚Ä¢ Esperados: $EXPECTED_TOTAL (M:$EXPECTED_MASTERS, W:$EXPECTED_WORKERS, S:$EXPECTED_STORAGE)"
echo "   ‚Ä¢ Actuales: $ACTUAL_NODES"
echo "   ‚Ä¢ Listos: $READY_NODES"

if [ "$READY_NODES" -eq "$EXPECTED_TOTAL" ]; then
  echo "‚úÖ Todos los nodos esperados est√°n listos"
else
  echo "‚ö†Ô∏è  No todos los nodos est√°n listos"
fi

# Verificar nodos por tipo espec√≠fico
echo ""
echo "üîç Verificaci√≥n por tipo de nodo:"

# Masters
MASTER_NODES=$(kubectl get nodes -l rke2-master=true --no-headers | wc -l || echo "0")
echo "   ‚Ä¢ Masters: $MASTER_NODES/$EXPECTED_MASTERS $([ "$MASTER_NODES" -eq "$EXPECTED_MASTERS" ] && echo "‚úÖ" || echo "‚ùå")"

# Workers
WORKER_NODES=$(kubectl get nodes -l rke2-worker=true --no-headers | wc -l || echo "0")
echo "   ‚Ä¢ Workers: $WORKER_NODES/$EXPECTED_WORKERS $([ "$WORKER_NODES" -eq "$EXPECTED_WORKERS" ] && echo "‚úÖ" || echo "‚ùå")"

# Storage
STORAGE_NODES=$(kubectl get nodes -l rke2-storage=true --no-headers | wc -l || echo "0")
echo "   ‚Ä¢ Storage: $STORAGE_NODES/$EXPECTED_STORAGE $([ "$STORAGE_NODES" -eq "$EXPECTED_STORAGE" ] && echo "‚úÖ" || echo "‚ùå")"

# 3. VERIFICACI√ìN DEL SISTEMA
# ===========================
echo ""
echo "üîß VERIFICACI√ìN DE PODS DEL SISTEMA"
echo "===================================="

echo "üì¶ Pods del sistema cr√≠ticos:"
kubectl get pods -n kube-system | grep -E "(etcd|kube-apiserver|kube-controller|kube-scheduler|kube-proxy|calico)"

echo ""
echo "üîç Estado de componentes cr√≠ticos:"

# Verificar etcd
ETCD_PODS=$(kubectl get pods -n kube-system -l component=etcd --no-headers | grep -c "Running" || echo "0")
ETCD_EXPECTED=$EXPECTED_MASTERS
echo "   ‚Ä¢ etcd: $ETCD_PODS/$ETCD_EXPECTED pods $([ "$ETCD_PODS" -eq "$ETCD_EXPECTED" ] && echo "‚úÖ" || echo "‚ùå")"

# Verificar API server
API_PODS=$(kubectl get pods -n kube-system -l component=kube-apiserver --no-headers | grep -c "Running" || echo "0")
echo "   ‚Ä¢ kube-apiserver: $API_PODS/$ETCD_EXPECTED pods $([ "$API_PODS" -eq "$ETCD_EXPECTED" ] && echo "‚úÖ" || echo "‚ùå")"

# Verificar CNI (Calico)
CALICO_PODS=$(kubectl get pods -n kube-system -l k8s-app=calico-node --no-headers | grep -c "Running" || echo "0")
echo "   ‚Ä¢ Calico CNI: $CALICO_PODS/$EXPECTED_TOTAL pods $([ "$CALICO_PODS" -eq "$EXPECTED_TOTAL" ] && echo "‚úÖ" || echo "‚ùå")"

# Verificar kube-proxy
PROXY_PODS=$(kubectl get pods -n kube-system -l k8s-app=kube-proxy --no-headers | grep -c "Running" || echo "0")
echo "   ‚Ä¢ kube-proxy: $PROXY_PODS/$EXPECTED_TOTAL pods $([ "$PROXY_PODS" -eq "$EXPECTED_TOTAL" ] && echo "‚úÖ" || echo "‚ùå")"

# 4. VERIFICACI√ìN DE CEPH
# =======================
echo ""
echo "üíæ VERIFICACI√ìN DE ALMACENAMIENTO CEPH"
echo "======================================="

if kubectl get namespace rook-ceph &>/dev/null; then
  echo "üìä Estado del cl√∫ster Ceph:"
  kubectl -n rook-ceph get cephcluster
  
  echo ""
  echo "üêö Pods de Ceph:"
  kubectl -n rook-ceph get pods | grep -E "(NAME|Running|Error|Pending)"
  
  # Contar componentes Ceph
  MON_PODS=$(kubectl -n rook-ceph get pods -l app=rook-ceph-mon --no-headers | grep -c "Running" || echo "0")
  MGR_PODS=$(kubectl -n rook-ceph get pods -l app=rook-ceph-mgr --no-headers | grep -c "Running" || echo "0")
  OSD_PODS=$(kubectl -n rook-ceph get pods -l app=rook-ceph-osd --no-headers | grep -c "Running" || echo "0")
  
  echo ""
  echo "üîç Componentes Ceph:"
  echo "   ‚Ä¢ MON pods: $MON_PODS $([ "$MON_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  echo "   ‚Ä¢ MGR pods: $MGR_PODS $([ "$MGR_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  echo "   ‚Ä¢ OSD pods: $OSD_PODS $([ "$OSD_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  
  # Verificar StorageClass
  echo ""
  echo "üíΩ StorageClasses:"
  kubectl get storageclass
  
  if kubectl get storageclass rook-ceph-block &>/dev/null; then
    echo "‚úÖ StorageClass rook-ceph-block disponible"
  else
    echo "‚ùå StorageClass rook-ceph-block no encontrada"
  fi
else
  echo "‚ö†Ô∏è  Namespace rook-ceph no encontrado - Ceph no est√° instalado"
fi

# 5. VERIFICACI√ìN DE METALLB
# ==========================
echo ""
echo "üåê VERIFICACI√ìN DE METALLB"
echo "=========================="

if kubectl get namespace metallb-system &>/dev/null; then
  echo "üìä Pods de MetalLB:"
  kubectl -n metallb-system get pods
  
  # Verificar componentes MetalLB
  CONTROLLER_PODS=$(kubectl -n metallb-system get pods -l app=metallb,component=controller --no-headers | grep -c "Running" || echo "0")
  SPEAKER_PODS=$(kubectl -n metallb-system get pods -l app=metallb,component=speaker --no-headers | grep -c "Running" || echo "0")
  
  echo ""
  echo "üîç Componentes MetalLB:"
  echo "   ‚Ä¢ Controller: $CONTROLLER_PODS pods $([ "$CONTROLLER_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  echo "   ‚Ä¢ Speaker: $SPEAKER_PODS pods $([ "$SPEAKER_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  
  # Verificar configuraci√≥n
  echo ""
  echo "üèä Configuraci√≥n de pools IP:"
  kubectl -n metallb-system get ipaddresspool
  
  echo ""
  echo "üì¢ Configuraci√≥n L2Advertisement:"
  kubectl -n metallb-system get l2advertisement
else
  echo "‚ö†Ô∏è  Namespace metallb-system no encontrado - MetalLB no est√° instalado"
fi

# 6. VERIFICACI√ìN DE RANCHER
# ==========================
echo ""
echo "üöÄ VERIFICACI√ìN DE RANCHER"
echo "=========================="

if kubectl get namespace cattle-system &>/dev/null; then
  echo "üìä Pods de Rancher:"
  kubectl -n cattle-system get pods -l app=rancher
  
  # Verificar componentes Rancher
  RANCHER_PODS=$(kubectl -n cattle-system get pods -l app=rancher --no-headers | grep -c "Running" || echo "0")
  
  echo ""
  echo "üîç Estado de Rancher:"
  echo "   ‚Ä¢ Rancher pods: $RANCHER_PODS/3 $([ "$RANCHER_PODS" -eq 3 ] && echo "‚úÖ" || echo "‚ùå")"
  
  # Verificar servicios
  echo ""
  echo "üåê Servicios de Rancher:"
  kubectl -n cattle-system get services
  
  # Verificar certificados
  echo ""
  echo "üîê Certificados:"
  kubectl -n cattle-system get certificates 2>/dev/null || echo "No se encontraron certificados"
  
  # Verificar ingress
  echo ""
  echo "üìã Ingress:"
  kubectl -n cattle-system get ingress 2>/dev/null || echo "No se encontraron ingress"
  
  # Verificar acceso HTTPS
  if [ -n "${RANCHER_DOMAIN:-}" ]; then
    echo ""
    echo -n "üåê Verificando acceso HTTPS a $RANCHER_DOMAIN: "
    if curl -k --max-time 10 -s -I "https://$RANCHER_DOMAIN" | grep -q "200 OK"; then
      echo "‚úÖ Rancher responde correctamente"
    else
      echo "‚ùå Rancher no responde"
    fi
  fi
else
  echo "‚ö†Ô∏è  Namespace cattle-system no encontrado - Rancher no est√° instalado"
fi

# 7. VERIFICACI√ìN DE CERT-MANAGER
# ===============================
echo ""
echo "üîê VERIFICACI√ìN DE CERT-MANAGER"
echo "==============================="

if kubectl get namespace cert-manager &>/dev/null; then
  echo "üìä Pods de cert-manager:"
  kubectl -n cert-manager get pods
  
  # Verificar componentes cert-manager
  CM_PODS=$(kubectl -n cert-manager get pods -l app=cert-manager --no-headers | grep -c "Running" || echo "0")
  CAINJECTOR_PODS=$(kubectl -n cert-manager get pods -l app=cainjector --no-headers | grep -c "Running" || echo "0")
  WEBHOOK_PODS=$(kubectl -n cert-manager get pods -l app=webhook --no-headers | grep -c "Running" || echo "0")
  
  echo ""
  echo "üîç Componentes cert-manager:"
  echo "   ‚Ä¢ cert-manager: $CM_PODS pods $([ "$CM_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  echo "   ‚Ä¢ cainjector: $CAINJECTOR_PODS pods $([ "$CAINJECTOR_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
  echo "   ‚Ä¢ webhook: $WEBHOOK_PODS pods $([ "$WEBHOOK_PODS" -ge 1 ] && echo "‚úÖ" || echo "‚ùå")"
else
  echo "‚ö†Ô∏è  Namespace cert-manager no encontrado - cert-manager no est√° instalado"
fi

# 8. CREAR APLICACI√ìN DE PRUEBA
# =============================
echo ""
echo "üß™ CREANDO APLICACI√ìN DE PRUEBA"
echo "==============================="

# Limpiar aplicaci√≥n previa si existe
kubectl delete -f test-app-complete.yaml --ignore-not-found &>/dev/null || true
sleep 5

echo "üì¶ Desplegando aplicaci√≥n de prueba completa..."

cat > test-app-complete.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-nginx
  namespace: default
  labels:
    app: test-nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: test-nginx
  template:
    metadata:
      labels:
        app: test-nginx
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: test-nginx-svc
  namespace: default
  labels:
    app: test-nginx
spec:
  type: LoadBalancer
  selector:
    app: test-nginx
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-pvc
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: rook-ceph-block
  resources:
    requests:
      storage: 1Gi
EOF

kubectl apply -f test-app-complete.yaml

# Esperar a que la aplicaci√≥n est√© lista
echo "‚è≥ Esperando que la aplicaci√≥n est√© lista..."
kubectl wait --for=condition=Available deployment/test-nginx --timeout=180s

echo ""
echo "üìä Estado de la aplicaci√≥n de prueba:"
kubectl get deployment test-nginx
kubectl get pods -l app=test-nginx
kubectl get service test-nginx-svc
kubectl get pvc test-pvc

# Verificar PVC
PVC_STATUS=$(kubectl get pvc test-pvc -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
echo ""
echo "üíæ Estado del almacenamiento:"
echo "   ‚Ä¢ PVC test-pvc: $PVC_STATUS $([ "$PVC_STATUS" = "Bound" ] && echo "‚úÖ" || echo "‚ùå")"

# Verificar LoadBalancer
EXTERNAL_IP=$(kubectl get service test-nginx-svc -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")

if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ]; then
  echo "   ‚Ä¢ LoadBalancer IP: $EXTERNAL_IP ‚úÖ"
  
  # Probar conectividad HTTP
  echo -n "   ‚Ä¢ Conectividad HTTP: "
  if curl -s --max-time 10 "http://$EXTERNAL_IP" | grep -q "nginx" &>/dev/null; then
    echo "‚úÖ Funcional"
  else
    echo "‚ùå Sin respuesta"
  fi
else
  echo "   ‚Ä¢ LoadBalancer IP: Pendiente ‚è≥"
fi

# 9. VERIFICAR RECURSOS DEL CL√öSTER
# =================================
echo ""
echo "üìä RECURSOS DEL CL√öSTER"
echo "======================="

echo "üß† Uso de memoria por nodo:"
kubectl top nodes --no-headers 2>/dev/null | while read -r node cpu memory rest; do
  echo "   ‚Ä¢ $node: $memory memoria"
done || echo "   ‚ö†Ô∏è  Metrics server no disponible"

echo ""
echo "üíΩ Uso de almacenamiento:"
kubectl get pv 2>/dev/null | grep -v NAME || echo "   ‚ö†Ô∏è  No hay Persistent Volumes"

echo ""
echo "üåê Servicios tipo LoadBalancer:"
kubectl get services -A | grep LoadBalancer || echo "   ‚ö†Ô∏è  No hay servicios LoadBalancer"

# 10. EVENTOS RECIENTES
# =====================
echo ""
echo "üìã EVENTOS RECIENTES DEL CL√öSTER"
echo "================================"
kubectl get events --sort-by=.metadata.creationTimestamp | tail -20

# 11. LIMPIEZA DE APLICACI√ìN DE PRUEBA
# ====================================
echo ""
echo "üßπ Limpiando aplicaci√≥n de prueba..."
kubectl delete -f test-app-complete.yaml
rm -f test-app-complete.yaml

# 12. RESUMEN FINAL
# =================
echo ""
echo "üìä RESUMEN DE VERIFICACI√ìN"
echo "=========================="

TOTAL_CHECKS=0
PASSED_CHECKS=0

# Funci√≥n para incrementar contadores
check_status() {
  local status=$1
  ((TOTAL_CHECKS++))
  if [ "$status" = "pass" ]; then
    ((PASSED_CHECKS++))
    echo "‚úÖ"
  else
    echo "‚ùå"
  fi
}

echo "üîç Componentes verificados:"

# Nodos
echo -n "   ‚Ä¢ Nodos del cl√∫ster: "
[ "$READY_NODES" -eq "$EXPECTED_TOTAL" ] && check_status "pass" || check_status "fail"

# Sistema
echo -n "   ‚Ä¢ Pods del sistema: "
[ "$ETCD_PODS" -ge 1 ] && [ "$API_PODS" -ge 1 ] && check_status "pass" || check_status "fail"

# Ceph (si est√° instalado)
if kubectl get namespace rook-ceph &>/dev/null; then
  echo -n "   ‚Ä¢ Almacenamiento Ceph: "
  [ "$OSD_PODS" -ge 1 ] && [ "$MON_PODS" -ge 1 ] && check_status "pass" || check_status "fail"
fi

# MetalLB (si est√° instalado)
if kubectl get namespace metallb-system &>/dev/null; then
  echo -n "   ‚Ä¢ MetalLB LoadBalancer: "
  [ "$CONTROLLER_PODS" -ge 1 ] && [ "$SPEAKER_PODS" -ge 1 ] && check_status "pass" || check_status "fail"
fi

# Rancher (si est√° instalado)
if kubectl get namespace cattle-system &>/dev/null; then
  echo -n "   ‚Ä¢ Rancher Management: "
  [ "$RANCHER_PODS" -eq 3 ] && check_status "pass" || check_status "fail"
fi

# cert-manager (si est√° instalado)
if kubectl get namespace cert-manager &>/dev/null; then
  echo -n "   ‚Ä¢ cert-manager: "
  [ "$CM_PODS" -ge 1 ] && [ "$WEBHOOK_PODS" -ge 1 ] && check_status "pass" || check_status "fail"
fi

echo ""
echo "üìà Resultado final: $PASSED_CHECKS/$TOTAL_CHECKS verificaciones exitosas"

if [ "$PASSED_CHECKS" -eq "$TOTAL_CHECKS" ]; then
  echo "üéâ ¬°Verificaci√≥n completada exitosamente!"
  echo "‚úÖ El cl√∫ster est√° completamente funcional"
else
  echo "‚ö†Ô∏è  Algunas verificaciones fallaron"
  echo "üí° Revisa los logs y corrige los problemas antes de continuar"
fi

echo ""
echo "üìÅ Informaci√≥n del cl√∫ster:"
echo "   ‚Ä¢ Configuraci√≥n: /etc/rancher/rke2/rke2.yaml"
echo "   ‚Ä¢ Logs del sistema: journalctl -u rke2-server"
if [ -n "${RANCHER_DOMAIN:-}" ]; then
  echo "   ‚Ä¢ Rancher UI: https://$RANCHER_DOMAIN"
fi

echo ""
echo "üëâ Contin√∫a con: scripts/07-test-ha.sh"
